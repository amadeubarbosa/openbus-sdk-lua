\documentclass[a4paper, 11pt,dvipdfm]{article}
\usepackage{a4}
\usepackage[latin1]{inputenc}
\usepackage{listings}
\usepackage{verbatim}
\usepackage{epsf}
\usepackage[dvips]{graphicx}
\usepackage[brazil]{babel}

\lstset{
  language = c++, 
  breaklines = true,
  breakatwhitespace = true,
  showlines = true
}

\title{Openbus SDK-Lua 1.5.2 - Documentação}
\author{Maíra Gatti\\
        Pontifícia Universidade Católica do Rio de Janeiro 
        (PUC-Rio)\\
        openbus-dev@tecgraf.puc-rio.br}
\date{Fevereiro 2011}

\begin{document}
\maketitle


\section{Visão Geral}

O OpenBus é um barramento de integração de serviços orientado \cite{Chappell} a componentes \cite{Szyperski1998} e baseado em CORBA \cite{OMG2004}\cite{pureCorba}. O Openbus usa o Oil (ORB in Lua) \cite{oil05} \cite{oil10}, um ORB de código fonte aberto e desenvolvido na linguagem Lua \cite{lua}.  O objetivo deste documento é o de descrever a estrutura e dinâmica da API sdk-lua 1.5.2 de acesso ao barramento para serviços desenvolvidos na linguagem Lua. Este documento não descreve o funcionamento interno do Openbus em si, também não descreve em detalhes o modelo de componentes SCS \cite{SCS} no qual o Openbus foi desenvolvido. Para mais informações sobre como usar a API Lua do SCS ou sobre informações básicas de uso e configuração da API sdk-lua para usuários iniciantes, veja o tutorial. Enquanto o tutorial descreve como \textbf{usar} a API, este documento descreve como \textbf{funciona} a API, ou seja, sua dinâmica interna.

Desta forma, considera-se como pré-requisito para um bom entendimento deste documento o conhecimento básico dos seguintes assuntos:

\begin{itemize}
	\item CORBA.
	\item Oil.
	\item Modelo de Componentes SCS v1.2.
	\item Conceitos básicos do Openbus.
	\item Linguagem de programação Lua.
\end{itemize}

Como Lua é uma linguagem interpretada, flexível e não orientada a objetos, existem alguns elementos citados nos diagramas que não possuem uma representação de objeto direto como ilustrado. Porém como não existiria outra forma de representar nos diagramas, eles foram representados conceitualmente afim de deixar a descrição da API didática e evitar inserção de código no manual.

\section{Entidades e Relacionamentos}

A API é composta pela fachada \textit{openbus.Openbus} e pelos pacotes \textit{authenticators}, \textit{lease}, \textit{interceptors}, \textit{faulttolerance} e \textit{util}. Além disso, a API usa os proxies dos serviços básicos: as facetas do Componente do Serviço de Controle de Acesso, do Serviço de Registro. 

Para um melhor aproveitamento da API, o desenvolvedor deverá usar o máximo possível as operações oferecidas pela fachada \textit{openbus.Openbus}, uma vez que ela encapsula os mecanismos de validação e renovação de credencial, obrigatórios para o acesso ao barramento, e encapsula os mecanismos opcionais de cache e de tolerância a falhas que melhoram a qualidade do serviço do barramento. Por outro lado, é importante entender como usar as operações do Serviço de Registro, uma vez que a fachada \textit{openbus.Openbus} não disponibiliza facilitadores em seu uso.

\begin{figure}[htb]
     \centering
\includegraphics[scale=0.68]{design/pngs/DiagramaClassesConexao.png}
     \caption{Modelo Conceitual das entidades de conexão com o barramento. As classes em azul são uma representação da implementação, elas não existem de fato.}
     \label{DiagramaClassesConexao}
\end{figure}

Na figura \ref{DiagramaClassesConexao} são ilustradas as entidades utilizadas no processo de conexão com o barramento. Dependendo do tipo de conexão solicitada pelo cliente, a fachada \textit{Openbus} utilizará o autenticador por login e senha, ou o autenticador por certificado. Ambos dependem do proxy da faceta do Serviço de Controle de Acesso que implementa a interface \textit{IAccessControlService}. Tais proxies estão representados pelas classes em azul: \textit{ACSFacetProxy} e \textit{ACSFacetSmartProxy}. A fachada \textit{Openbus} utilizará ou proxies normais ou \textit{smart} proxies. \textit{Smart} proxies são aqueles que são configurados com as referências para todas as réplicas do servant ao qual se refere de forma que, em caso de falha, o proxy possa redirecionar a chamada para outra réplica. Eles só serão utilizados na API, caso o mecanismo de Tolerância a Falhas seja habilitado. A fachada \textit{Openbus} também possui uma referência para a classe \textit{SmartComponent} \ref{smartcomponent} que é composta pelos \textit{smart} proxies de todas as facetas de um componente, no caso, o componente do Serviço de Controle de Acesso. 

A figura \ref{DiagramaClassesInterceptadores} ilustra as entidades envolvidas no processo de interceptação de um requisição, validação e renovação de credencial do cliente.

\begin{figure}[htb]
     \centering
\includegraphics[scale=0.7]{design/pngs/DiagramaClassesInterceptadores.png}
     \caption{Modelo Conceitual das entidades de interceptação e validação de credenciais. As classes em azul são uma representação da implementação, elas não existem de fato.}
     \label{DiagramaClassesInterceptadores}
\end{figure}

Sempre que o barramento é inicializado, a fachada \textit{Openbus} inicializa o ORB, que no caso é o \textit{Oil} com os interceptadores \textit{ClientInterceptor} e \textit{ServerInterceptor}. O interceptador \textit{ClientInterceptor} é responsável por pegar a credencial salva no \textit{CredentialManager} após o login no Serviço de Controle de Acesso, e inserir no contexto da requisição. Do lado do servidor, o interceptador \textit{ServerInterceptor} recupera a credencial do contexto da requisição e verifica na faceta que implementa a interface \textit{IAccessControlService} se a credencial é válida. Na figura \ref{DiagramaClassesInterceptadores}, é ilustrada a faceta \textit{AccessControlService\_v1\_05}. 

O interceptador \textit{ServerInterceptor} quando inicializado na aplicação servidor também inicializa uma \textit{thread}, representada conceitualmente pela classe \textit{CacheTimer} que implementa o padrão \textit{Template Method} e tem um relógio que de tempos em tempos executa a ação de verificação das credenciais salva na memória interna do interceptador para fins de otimização do processo de validação da credencial. Quando a aplicação cliente inicializa a fachada \textit{Openbus}, ela pode definir a política de validação de credencial que decidirá se este \textit{timer} será ativado. 

Finalmente a classe \textit{ServiceStatusManager} é responsável por, durante o envio de resposta da requisição, disparar o mecanismo de atualização de estado das réplicas. Tal mecanismo é ativado somente se existirem réplicas para serviço no qual o interceptador foi instalado.

A figura \ref{DiagramaClassesLease} por sua vez ilustra as entidades relacionadas com o processo de renovação da \textit{lease\footnote{\textit{Lease} é um termo originalmente usado para indicar uma locação. No contexto de credenciais, \textit{lease} significa o contrato de uso da credencial por um determinado período, período este definido pelo barramento.}}  de uma credencial. Se a credencial adquirida durante a conexão com o barramento não for renovada pela classe \textit{LeaseRenewer} em um tempo menor que o de sua expiração, ela não será mais válida no barramento e consequentemente a aplicação cliente do barramento não poderá nem ofertar nem consumir ofertas de serviços. Além disso, todas as ofertas já cadastradas no Serviço de Registro serão removidas.

\begin{figure}[htb]
     \centering
\includegraphics[scale=0.7]{design/pngs/DiagramaClassesLease.png}
     \caption{Modelo Conceitual das entidades de renovação da lease da credencial. As classes em azul são uma representação da implementação, elas não existem de fato.}
     \label{DiagramaClassesLease}
\end{figure}

A API sdk-lua-1.5.2 fornece operações na fachada \textit{Openbus} para o cliente especificar a classe que implementa a interface representada conceitualmente por \textit{ILeaseExpiredCallBack}. A classe \textit{LeaseRenewer} chama operações desta interface no momento em que a credencial expira. A  fachada \textit{Openbus} por sua vez implementa estas operações funcionando como um delegador.

Além disso o Serviço de Controle de Acesso sendo provedor de \textit{leases} implementa a interface conceitual \textit{ILeaseProvider}, porém a API é flexível para receber outros provedores se desejado.

Para que a lease seja renovada de tempos em tempos, a API possui uma \textit{thread} ilustrada pela classe \textit{LeaseTimer} que implementa a ação de renovação a partir do provedor.

\section{Inicialização do Openbus}

A figura \ref{OpenbusInitialization} descreve o processo de inicialização do barramento a partir da instanciação da classe \textit{Openbus} seguida da chamada do método \textit{init} pela aplicação cliente. Dois parâmetros são obrigatórios para a inicialização do barramento: o nome da máquina e número da porta onde o Serviço de Controle de Acesso se encontra. Em seguida a classe \textit{Openbus} inicializa o ORB enviando um arquivo de propriedades que define, entre outras informações, se as requisições são interceptáveis \cite{Interceptors}; carrega as IDLs das interfaces do barramento; e carrega\footnote{Esta última etapa é necessária por uma limitação do uso da fachada \textit{Openbus} como \textit{Singleton}, pois um como é utilizada nos interceptadores, se o \textit{require} for feito antes da classe Openbus tiver sido inicializada (o que aconteceria se o \textit{require} fosse feito no topo do arquivo), ocorreria um erro em tempo de execução alegando que \textit{Openbus} é \textbf{nil} dentro das classes \textit{ClientInterceptor} e \textit{ServerInterceptor}.} as classes dos interceptadores cliente e servidor. 

\begin{figure}[htb]
     \centering
\includegraphics[scale=0.5]{design/pngs/OpenbusInitialization.png}
     \caption{Inicialização do Openbus}
     \label{OpenbusInitialization}
\end{figure}

\pagebreak

\section{Mecanismo de Conexão e Desconexão}

Após inicializar o barramento, a aplicação cliente pode se conectar. A conexão pode ser feita de duas formas: por \textit{login} e senha ou por certificado através das operações \textit{connectByLoginPassword()} e \textit{connectByCertificate()}, respectivamente.

A figura \ref{Loginbypassword} ilustra o processo de conexão através de \textit{login} e senha\footnote{Veja como é análogo o processo por certificado na figura \ref{Loginbycertificate}.}. Durante este processo, o autenticador \textit{LoginPasswordAuthenticator} é criado com as informações de \textit{login} e senha. De posse da instância do autenticador, a classe \textit{Openbus} pode então realizar o procedimento de conexão básico descrito no diagrama \textit{Core Connection} (figura \ref{CoreConnection}) que, em um dado momento, irá chamar a operação \textit{authenticate()} que, por sua vez, irá diferenciar o tipo de acesso ao Serviço de Controle de Acesso propriamente dito.

\begin{figure}[htb]
     \centering
     \includegraphics[scale=0.7]{design/pngs/Loginbypassword.png}
     \caption{Conexão por senha}
     \label{Loginbypassword}
\end{figure}

\begin{figure}[htb]
     \centering
     \includegraphics[scale=0.7]{design/pngs/Loginbycertificate.png}
     \caption{Conexão por certificado}
     \label{Loginbycertificate}
\end{figure}

\begin{figure}[p]
     \centering
     \includegraphics[scale=0.65]{design/pngs/CoreConnection.png}
     \caption{Processo de conexão básico}
     \label{CoreConnection}
\end{figure}

\pagebreak

O primeiro passo do processo de conexão básico (veja figura \ref{CoreConnection}) é verificar se o cliente já não está conectado. Para isto, a classe \textit{Openbus} verifica se o \textit{CredentialManager} possui alguma credencial salva em seu estado a partir da operação \textit{hasValue()} que retorna um \textit{boolean}. Não está ilustrado no diagrama, mas se já estiver conectado, o barramento não deixa se conectar novamente e simplesmente retorna falso. Se nenhuma credencial foi encontrada e não existe uma referência para o proxy do Serviço de Controle de Acesso, a classe \textit{Openbus} primeiramente tenta encontrá-la. Isso sempre acontecerá na primeira conexão uma vez que esta referência é postergada até este momento. Depois a referência é salva e, se ela se tornar inválida ou inacessível, a classe \textit{Openbus} tentará obter uma nova (no caso de existirem réplicas do Serviço de Controle de Acesso).

De posse da referência para o proxy do Serviço de Controle de Acesso, a classe \textit{Openbus} chama a operação \textit{authenticate()} na instância do autenticador que, neste caso, simplesmente chama a operação \textit{loginbypassword()} no Serviço de Controle de Acesso.

Se o \textit{loginbypassword()} for executado com sucesso, a classe \textit{Openbus} receberá a credencial e a \textit{lease} da credencial. A conexão é finalizada então pela operação privada \textit{\_completeConnection()} que: 

\begin{enumerate}
\item salva a credencial no \textit{CredentialManager},
\item instancia a classe \textit{LeaseRenewer},
\item inicia o \textit{timer} de renovação através da mensagem \textit{startRenew()}, e
\item recupera e retorna a referência para o Serviço de Registro.
\end{enumerate}

O processo de autenticação por certificado através da classe \textit{CertificateAuthenticator} por outro lado precisa ler o certificado do cliente antes de efetuar o login no barramento. Este procedimento usa a API externa \textit{LCE - Lua Cryptography Extension} \cite{lce} que é uma biblioteca de \textit{binding} da biblioteca \textit{OpenSSL crypto} \cite{openssl} para a linguagem Lua, e é ilustrado na figura \ref{CertificateEncryption}.

\begin{figure}[htb]
     \centering
     \includegraphics[scale=0.7]{design/pngs/CertificateEncryption.png}
     \caption{Leitura do Certificado}
     \label{CertificateEncryption}
\end{figure}

\begin{figure}[htb]
     \centering
     \includegraphics[scale=0.6]{design/pngs/Disconnect.png}
     \caption{Desconexão}
     \label{disconnect}
\end{figure}

O processo de desconexão é simples (figura \ref{disconnect}). Se o \textit{CredentialManager} tiver uma credencial, seu processo de renovação será parado, a credencial será deslogada do Serviço de Controle de Acesso (que por sua vez remove todas as ofertas associadas a ela), ela será invalidada e o cliente receberá um retorno de sucesso. Se algo de errado acontecer durante esse processo, o cliente receberá uma mensagem de erro.

\section{Mecanismo de Lease e Renovação da Credencial}

Durante o processo de conexão, como descrito na seção anterior, após o \textit{login} no barramento, seja por senha, seja por certificado, a API recebe a \textit{lease} da credencial que é a sua validade. O processo então de renovação da credencial é iniciado. A figura \ref{LeaseRenewProcess} descreve esse processo a partir do seu início pela chamada \textit{startRenew()}. A classe \textit{LeaseRenewer} verifica se o \textit{timer} já não foi criado antes. Caso não tenha sido, cria sua instância passando o tempo fornecido pelo \textit{lease}. O \textit{timer} representado conceitualmente pela classe \textit{LeaseTimer} executa a operação \textit{\_renewLeaseAction()}. Durante sua execução, a operação \textit{renewLease()} do provedor é executada. Nesse caso, o provedor da lease é o Serviço de Controle de Acesso e esta operação faz parte de uma das suas facetas: \textit{ILeaseProvider}.

Durante o processo de renovação da credencial, se a renovação for executada com sucesso, uma nova \textit{lease} é fornecida. O tempo do \textit{LeaseTimer} é atualizado com este valor.

Caso o processo de renovação não seja autorizado, \textit{LeaseRenewer} irá enviar a mensagem \textit{expired()} para a instância da classe que implementa a interface \textit{ILeaseExpiredCallback}. Como já explicado anteriormente, a API foi desenhada para que a fachada \textit{Openbus} implemente esta interface sendo um delegador para o objeto criado pela aplicação cliente. Antes de delegar, a fachada \textit{Openbus} é 'resetada', ou seja, todas as referências para as facetas do Serviço de Controle de Acesso e Registro são invalidadas, assim como o estado de \textit{CredentialManager}.

É importante notar que a API não fornece uma implementação padrão de reconexão da \textit{callback} uma vez que poderia induzir o desenvolvedor de um servidor cliente do barramento a usá-la e não considerar que as ofertas registradas não foram registradas novamente com a re-conexão (e, lembrando, elas são removidas quando uma credencial expira ou é deslogada manualmente).

\begin{figure}[p]
     \centering
     \includegraphics[scale=0.53, angle=90]{design/pngs/LeaseRenewProcess.png}
     \caption{Processo de Renovação de Lease de Credencial}
     \label{LeaseRenewProcess}
\end{figure}

\section{Mecanismo de Interceptação e Validação da Credencial}

Como já visto, o Oil é inicializado com interceptação de requisições, e dois interceptadores são instalados: \textit{ClientInterceptor} e \textit{ServerInterceptor}. Desta forma, sempre que uma requisição para os serviços básicos for realizada, tal como pedir para cadastrar uma oferta, ou removê-la, ou uma requisição para um serviço registrado no barramento, tais requisições serão interceptadas para verificar se possuem credencial e se a credencial é válida no Serviço de Controle de Acesso.

\begin{figure}[p]
     \centering
     \includegraphics[scale=0.6, angle=90]{design/pngs/InterceptionCredentialsValidation.png}
     \caption{Interceptadores e Validação da Credencial}
     \label{InterceptionCredentialsValidation}
\end{figure}

A figura \ref{InterceptionCredentialsValidation} ilustra esse processo. Uma aplicação cliente representada pela classe \textit{Service} envia a requisição para o proxy em questão, que pode ser do Serviço de Registro ou de outro serviço cadastrado no barramento, e a requisição é interceptada por \textit{ClientInterceptor} através da mensagem \textit{sendrequest()}. A credencial é então verificada no \textit{CredentialManager} e, caso exista ela é inserida no contexto da requisição (veja mensagem 1.1.1.1.3). A requisição é redirecionada pelo Oil para o interceptador servidor (\textit{ServerInterceptor}) que, pelo nome da requisição, vai verificar se é interceptável ou não (mensagem 1.1.1.2.2). Se interceptável, o interceptador vai tentar recuperar a credencial do contexto e validá-la na faceta \textit{AccessControlService\_v1\_05}. Se a credencial foi recuperada do contexto e é válida, a requisição é processada normalmente no servidor alvo, senão o interceptador servidor enviará para o cliente a exceção \textit{NO\_PERMISSION}.

\section{Qualidade do Serviço}

A API sdk-lua 1.5.2 fornece dois mecanismos que melhoram a qualidade do serviço do barramento: mecanismo de cache e mecanismo de tolerância a falhas. As seções a seguir descrevem como eles funcionam.

\subsection{Mecanismo de Cache}

Mecanismos de Cache são os relativos as diferentes políticas de validação de credencial. Atualmente, existem três políticas que podem ser usadas:

\begin{description}
\item[NONE] Indica que as credenciais interceptadas não serão validadas;
\item[ALWAYS] Indica que as credenciais interceptadas serão sempre validadas.
\item[CACHED] Indica que as credenciais interceptadas serão validadas e armazenadas em uma \textit{cache};
\end{description}

O padrão é \textit{ALWAYS}, ou seja, sempre validadas. Porém o cliente pode inicializar o barramento com a política \textit{CACHED} para otimizar as requisições, uma vez que se a credencial estiver armazenada na \textit{cache} não será preciso enviar uma requisição de validação pela rede.

Atualmente a política \textit{NONE} é utilizada somente em casos específicos do barramento, uma vez que o cliente não conseguiria registrar ou consumir nenhum serviço se esta política estiver habilitada.

A figura \ref{CacheMechanism} ilustra a troca de mensagens durante o processo de verificação da política pelo interceptador servidor seguida da validação em si. No momento em que o intercetador servidor é inicializado, a política passada é verificada. Se for \textit{CACHED}, um \textit{timer} será criado (ilustrado conceitualmente pela classe \textit{CacheTimer}). Posteriormente, quando uma requisição do cliente for interceptada, a requisição é bloqueada, a credencial é buscada na cache, se encontrada, o índice é atualizado, a requisição desbloqueada e redirecionada para o servidor alvo. 

Se não for encontrada, a requisição também é desbloqueada porém a credencial é verificada no Serviço de Controle de Acesso. Como pode ser que a credencial inserida no contexto seja de uma versão anterior do barramento, é preciso passar as duas credenciais inseridas no contexto (atual e anterior, veja a figura \ref{Cache_isValid}).  Se a credencial foi validada, tenta-se adicioná-la na \textit{cache}. Ela só não será adicionada se a cache já tiver atingido o seu limite máximo permitido. 

Os outros casos, \textit{NONE} e \textit{ALWAYS} são ilustrados nos blocos inferiores.

Já a figura \ref{CacheCredentialValidatorAction} ilustra a troca de mensagens durante o processo de validação das credenciais que estão na \textit{cache}. De tempos em tempos, o \textit{timer} representado pela classe \textit{CacheTimer} executa a ação \textit{credentialValidatorAction()}. Este por sua vez verifica se não está bloqueado (está somente quando uma credencial está sendo verificada na cache no momento de uma requisição), e se não estiver, bloqueia e verifica todas as credenciais de uma só vez no Serviço de Controle de Acesso através da chamada \textit{areValid()} na faceta \textit{AccessControlService\_v1\_05}. Se alguma delas não for válida, é removida da \textit{cache}.

\begin{figure}[p]
     \centering
     \includegraphics[scale=0.54]{design/pngs/CacheMechanism.png}
     \caption{Mecanismo de Cache}
     \label{CacheMechanism}
\end{figure}

\begin{figure}[htb]
     \centering
     \includegraphics[scale=0.6]{design/pngs/Cache_isValid.png}
     \caption{Validação no Serviço de Controle de Acesso}
     \label{Cache_isValid}
\end{figure}

\begin{figure}[p!]
     \centering
     \includegraphics[scale=0.6]{design/pngs/CacheCredentialValidatorAction.png}
     \caption{Validação das Credencias em Cache}
     \label{CacheCredentialValidatorAction}
\end{figure}



\subsection{Mecanismo de Tolerância a Falhas}

O barramento possui um mecanismo de tolerância a falhas baseado em replicação. Ou seja, ele assume que pode existir mais de uma réplica do componente do Serviço de Controle de Acesso ativa em um dado momento. Para que este mecanismo possa funcionar corretamente, é preciso configurar os endereços das réplicas do Serviço de Controle de Acesso acessíveis no arquivo \textit{"/conf/ACSFaultToleranceConfiguration.lua"}.

Além disso, o barramento define alguns tempos padrão usados durante a detecção e tratamento de falhas em uma determinada requisição. Esses tempos são definidos no arquivo de configuração \textit{/conf/FTTimeOutConfiguration.lua}:
\begin{description}
   \item[reply] Tempo de resposta de uma requisição normal;
   \item[non\_existent] Tempo de resposta de uma requisição que testa se o objeto remoto existe;
   \item[fetch] Tempo de busca por alguma réplica disponível.
\end{description}

Como ilustrado na figura \ref{FaultToleranceOpenbusInitialization}, para habilitar o mecanismo de tolerância a falhas é preciso executar o método \textit{enableFaultTolerance()} na fachada \textit{Openbus}. Esta chamada irá criar uma instância do \textit{SmartComponent} do Serviço de Controle de Acesso, que nada mais é que um gerenciador dos \textit{smart} proxies de suas facetas.

Note que o método \textit{enableFaultTolerance()} deve ser chamada logo após a chamada do \textit{init()} ou o mecanismo não estará ativado para quaisquer operações da API Openbus ou requisições ao barramento seguintes a sua inicialização.

\begin{figure}[p]
     \centering
     \includegraphics[scale=0.7]{design/pngs/FaultToleranceOpenbusInitialization.png}
     \caption{Inicialização do Openbus com Mecanismo de Tolerância a Falhas}
     \label{FaultToleranceOpenbusInitialization}
\end{figure}

\begin{figure}[p]
     \centering
     \includegraphics[scale=0.65, angle=90]{design/pngs/FaultToleranceFetchACSSmartComponent.png}
     \caption{Configuração do Smart Component do Serviço de Controle de Acesso}
     \label{FaultToleranceFetchACSSmartComponent}
\end{figure}

O \textit{SmartComponent} por sua vez, no momento em que for definir os \textit{smart} proxies, vai carregar do arquivo de configuração \textit{/conf/FTTimeOutConfiguration.lua} o tempo de busca (\textit{fetch}), e para cada réplica definida a partir do arquivo de configuração \textit{"/conf/ACSFaultToleranceConfiguration.lua"}, um proxy será buscado no Oil (veja o diagrama da figura \ref{FaultToleranceFetchACSSmartComponent}). Enquanto uma faceta buscada não estiver disponível e o tempo não tiver se esgotado, o processo de busca continua iterando nas réplicas. Ou seja, o processo só para se o tempo tiver sido antigido ou todas as facetas do componente, no caso o Serviço de Controle de Acesso, estiverem disponíveis e respondendo corretamente. A mensagem 1.5 muda os proxies da facetas encontradas de \textit{'synchronous'} para \textit{'smart'}, tornando-os \textit{smart} proxies.

A figura \ref{FaultToleranceExceptionHandling} ilustra como a API trata a exceção através do Smart Proxy para garantir que uma requisição não falhe. Desta forma, suponha que o cliente tenha requisitado a operação \textit{logout}, se uma das  exceções abaixo for recebida, o Smart Proxy tentará achar outra réplica válida para redirecionar a requisição:

\begin{verbatim}
  IDL:omg.org/CORBA/NO_RESPONSE:1.0
  IDL:omg.org/CORBA/COMM_FAILURE:1.0
  IDL:omg.org/CORBA/OBJECT_NOT_EXIST:1.0
  IDL:omg.org/CORBA/TRANSIENT:1.0
  IDL:omg.org/CORBA/TIMEOUT:1.0
  IDL:omg.org/CORBA/NO_RESOURCES:1.0
  IDL:omg.org/CORBA/FREE_MEM:1.0
  IDL:omg.org/CORBA/NO_MEMORY:1.0
  IDL:omg.org/CORBA/INTERNAL:1.0
\end{verbatim} 

A busca acontecerá enquanto uma réplica sem falhas não for encontrada ou o tempo máximo definido tiver sido atingido. E a operação \textit{smartmethod()} é executada recursivamente\footnote{Na figura \ref{FaultToleranceExceptionHandling} a recursão é representada pelo \textit{loop} com a condição de guarda \textit{while not reply} e \textit{reply} é um atributo público para esta operação, ou seja, uma vez retornada corretamente, o laço termina.} no caso de uma réplica sem falhas tiver sido encontrada e enquanto ocorrer um exceção, exceto por TIME\_OUT, que é lançada quando nenhuma réplica válida é encontrada ou consegue responder a requisição no tempo especificado pelo cliente. 

Note que foi omitida a sequência de mensagens a partir da mensagem \textit{1.1.1 reply, exception = invoke()} pois a descrição sobre como a chamada é realizada, depois transferida para os interceptadores, e a credencial validada antes da requisição ser redirecionada para o objeto remoto alvo, foi ilustrada na figura \ref{InterceptionCredentialsValidation} a partir da mensagem 1.1.1. 

\begin{figure}[p]
     \centering
     \includegraphics[scale=0.6]{design/pngs/FaultToleranceExceptionHandling.png}
     \caption{Mecanismo de Tratamento de Exceção do FT}
     \label{FaultToleranceExceptionHandling}
\end{figure}

\section{Ofertando Serviços}

O processo básico de cadastro de oferta de serviços é ilustrado no diagrama da figura \ref{ServiceOfferProcess}. O serviço a ser registrado no barramento deve ser descrito através de uma oferta de serviço, que é representada pela estrutura \textit{ServiceOffer}.Para que um servidor possa ofertar serviços no barramento através da API sdk-lua-1.5.2 é preciso:

\begin{enumerate}
 \item Inicializar o barramento;
 \item Conectar no barramento;
 \item Habilitar o processo servidor a escutar as requisições CORBA que serão direcionadas para o serviço ofertado, o que pode ser feito através da mensagem \textit{run()};
 \item Cadastrar a oferta através da operação \textit{register} chamada no proxy do Serviço de Registro.
\end{enumerate}

Para cadastrar a oferta é preciso que o servidor componente passe a sua faceta \textit{IComponent} e as propriedades que descrevem as ofertas. 

Após a chamada da operação \textit{register}, a sequência de mensagens segue como descrito no diagrama de interceptação e validação de credenciais, veja figura \ref{InterceptionCredentialsValidation}.


\begin{figure}[htb]
     \centering
     \includegraphics[scale=0.7]{design/pngs/ServiceOfferProcess.png}
     \caption{Processo básico de oferta de serviços}
     \label{ServiceOfferProcess}
\end{figure}

\section{Consumindo Serviços}

O processo básico de busca de ofertas de serviços é ilustrado no diagrama da figura \ref{FindingServicesOffers}. Para que uma aplicação cliente possa consumir serviços registrados no barramento através da API sdk-lua-1.5.2 é preciso:

\begin{enumerate}
 \item Inicializar o barramento;
 \item Conectar no barramento;
 \item Buscar o serviço através da mensagem \textit{find} e passando alguma informação sobre o serviço, tal como uma parte do nome da interface, como por exemplo \textit{IHello};
 \item O cliente receberá uma lista de ofertas que implementam a faceta buscada, na qual deverá iterar e para cada uma delas mapear a interface \textit{IComponent} usando a operação \textit{narrow} da API do SCS;
 \item Através da faceta \textit{IComponent}, buscar a faceta do componente desejada, como por exemplo '\textit{IDL:demoidl/hello/IHello:1:0}'; 
 \item Mapear a faceta retornada para a interface desejada usando a operação \textit{narrow} da API do SCS; e finalmente
 \item Executar o serviço desejado, como por exemplo \textit{sayHello()}.
\end{enumerate}


\begin{figure}[htb]
     \centering
     \includegraphics[scale=0.6]{design/pngs/FindingServicesOffers.png}
     \caption{Buscando por serviços no barramento}
     \label{FindingServicesOffers}
\end{figure}


\begin{thebibliography}{50}
\bibitem[1]{Chappell}
Chappell, D. 2004 Enterprise Service Bus. O'Reilly Media, Inc.

\bibitem[2]{Szyperski1998}
Szyperski, C. Component Software: Beyond Object-Oriented Programming. ACM Press : Addison-Wesley Publishing Co. 1998.

\bibitem[3]{OMG2004}
OMG. CORBA Components. OMG Document formal/04-03-01 (CORBA, v3.0.3). 2004. http://www.omg.org

\bibitem[4]{pureCorba}
Bolton, F.; \textit{Pure} CORBA. Sams Publishing, 2002.

\bibitem[5]{oil05}
Maia, R., Cerqueira, R. and Kon, F.; A Middleware for Experimentation on Dynamic Adaptation. In Proc. 4th Workshop on Adaptive and Reflective Middleware (ARM2005), co-located with 6th International Middleware Conference, Grenoble, France, November 2005.

\bibitem[6]{oil10}
The Oil Project: An Object Request Broker in Lua. http://oil.luaforge.net/index.html

\bibitem[7]{lua}
Linguagem de Programação Lua. http://www.lua.org/

\bibitem[8]{SCS}
The SCS Project. http://www.tecgraf.puc-rio.br/~scorrea/scs/

\bibitem[9]{smartcomponent}
Gatti, M., Cerqueira, R.; Design Experiences and Strategies on Applying Fault-Tolerance in a Component-based Enterprise Service Bus. Technical Report, Tecgraf, PUC-Rio, 2010.

\bibitem[10]{Interceptors}
OMG. CORBA Interceptors. OMG Document formal/04-03-01 (CORBA, v3.0.3). 2004. http://www.omg.org

\bibitem[11]{lce}
LCE - Lua Cryptography Extension. http://luaforge.net/projects/lce/

\bibitem[10]{openssl}
OpenSSL crypto. http://www.openssl.org/docs/crypto/crypto.html

\end{thebibliography}

\end{document}

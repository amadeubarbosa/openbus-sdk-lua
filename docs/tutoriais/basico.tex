\documentclass[12pt]{article}

%% Estilos e Plug-Ins
\usepackage{a4}
\usepackage{times}
\usepackage[latin1]{inputenc}
\usepackage[brazil]{babel}
\usepackage[T1]{fontenc}
\usepackage{listings}
\usepackage{color}
\usepackage{epsfig}
\usepackage{mwlabinputs}
\usepackage{hyperref}

\setlength{\parskip}{6mm}
\textheight=8.2in

%% Redefines the label 'Listing' to ..
\def\lstlistingname{Código}
\lstset{inputencoding=latin1}
\codestyle{colorful}
%% Removes hyperlinks borders
\hypersetup{
  pdfborder = {0 0 0},
}

\newcommand{\code}[1]{\texttt{#1}}

% ===================
% Inicio do documento
% ===================

\begin{document} 

\title{OpenBus-Lua - Tutorial - API}
\author{C. Augusto, R. Cosme, R. Cerqueira, M. Gatti \\
        Tecgraf \\
        Pontifícia Universidade Católica do Rio de Janeiro 
        (PUC-Rio)\\
        openbus-dev@tecgraf.puc-rio.br}

\date{\today}
\maketitle

\pagenumbering{arabic}

\section{Introdução}

Este documento é destinado aos usuários desenvolvedores de aplicações Lua que desejem utilizar o OpenBus. O processo de \emph{deployment} do barramento não é coberto aqui neste tutorial. Considera-se como pré-requisito para um bom entendimento deste documento o conhecimento básico dos seguintes assuntos:

\begin{itemize}
	\item Linguagem de programação Lua.
	\item CORBA.
	\item Modelo de Componentes SCS.
	\item Conceitos básicos do Openbus.
\end{itemize}

Maiores informações podem ser obtidas em:
\url{http://www.tecgraf.puc-rio.br/openbus}

\section{Preparação do Ambiente}

O OpenBus utiliza o mecanismo de interceptação de CORBA no processo de controle de acesso aos serviços. Após a chamada de requisição de \emph{login} no barramento, todas as chamadas seguintes devem estar com a credencial de acesso anexada. Sendo assim, faz-se necessário a habilitação dos interceptadores frente ao ORB que será utilizado. No OpenBus-Lua o ORB utilizado será o OiL, e o barramento se encarregará da instalação dos interceptadores em sua inicialização, sendo necessário apenas que o usuário forneça as configurações dos interceptadores. Por padrão, a API Openbus utiliza as configurações definidas no arquivo \textit{"/conf/advanced/InterceptorsConfiguration.lua"}.

\subsection{Preparação do Ambiente com Mecanismo de Tolerância a Falhas}

O barramento possui um mecanismo de tolerância a falhas baseado em replicação. Ou seja, pode existir mais de uma réplica do componente do Serviço de Controle de Acesso ou do Serviço de Registro ativos em um dado momento. Para que este mecanismo possa funcionar corretamente, é preciso configurar os endereços das réplicas do Serviço de Controle de Acesso acessíveis no arquivo \textit{"/conf/ACSFaultToleranceConfiguration.lua"}.

Além disso, o barramento define alguns tempos padrão usados durante a detecção e tratamento de falhas em uma determinada requisição. Se o cliente achar necessário, é possível modificar esses tempos no arquivo de configuração \textit{/conf/FTTimeOutConfiguration.lua}. Os seguintes atributos podem ser configurados, inclusive em tempo de execução:
\begin{enumerate}
   \item Tempo de resposta de uma requisição normal (atributo reply);
   \item Tempo de resposta de uma requisição que testa se o objeto remoto existe (atributo non\_existent);
   \item Tempo de busca por alguma réplica disponível (atributo fetch).
\end{enumerate}
\begin{labeledcode}[lua]{ftconfig}{Configuração padrão dos tempos do mecanismo de tolerância a falhas}
reply =        {  MAX_TIMES = 600,
                  sleep = 0.1,
               },
non_existent = {  MAX_TIMES = 30,
                  sleep = 0.1,
               },
fetch        = {  MAX_TIMES = 22,
                 sleep = 5,
               },
\end{labeledcode}
	
\subsection{Teste}

Antes de se começar a programação, é aconselhável que o usuário coloque em funcionamento a demo Hello que acompanha o pacote. O correto funcionamento da demo elimina uma série de possíveis problemas que o desenvolvedor possa enfrentar durante o seu projeto, como por exemplo: problemas de comunicação com o barramento, serviços básicos não disponíveis e ausência de bibliotecas externas.

Naturalmente a execução da demo necessita de um barramento em operação. A demo pode ser executada seguindo os seguintes passos:
\begin{itemize}
  \item Entrar no diretório \$OPENBUS\_HOME/demo/hello/lua.
  \item Editar os arquivos server.lua e client.lua em \$OPENBUS\_HOME/demo/hello/lua/ e configurar a localização do barramento.
  \item Executar a demo: ./run
\end{itemize}

Após a execução do cliente, no terminal a seguinte mensagem deve ser exibida pelo processo servidor, entre outras: ``HELLO!"

\section{Desenvolvimento}

\subsection{API}\label{api}

A API é composta pelo módulo \textit{openbus.Openbus}, pela interface
\textit{IRegistryService} advinda da IDL do Serviço de Registro e pelo módulo
\textit{faulttolerance.SmartComponent}. O módulo Openbus atualmente é
implementado como o padrão \emph{singleton}, pois suporta apenas um barramento. 
Para se obter a instância do barramento e (re)inicializá-la, deve-se utilizar o
Código~\ref{lst:barramento}.

\begin{labeledcode}[lua]{barramento}{Obtenção da Instância do Barramento}
-- obtenção da instância do barramento
local openbus = require "openbus.Openbus"

-- host e porta apenas para fins de exemplo
openbus:init("localhost", 2089)
\end{labeledcode}

Um ORB é criado implicitamente na chamada \emph{init}.

Em adição, para que o cliente possa se beneficiar do mecanismo de tolerância a falhas de forma transparente, é necessário habilitar o mecanismo através do método \textit{enableFaultTolerance()} (vide Código~\ref{lst:ft}, linha 7). Desta forma, a API vai configurar um \textit{SmartComponent} para o Serviço de Controle de Acesso, que é um \emph{stub} com mecanismos de detecção e tratamento de falhas.

\begin{labeledcode}[lua]{ft}{Obtenção da Instância do Barramento com Mecanismo de Tolerância a Falhas Ativado}
-- obtenção da instância do barramento
local openbus = require "openbus.Openbus"

-- host e porta apenas para fins de exemplo
openbus:init("localhost", 2089)

openbus:enableFaultTolerance()
\end{labeledcode}

Se os endereços das réplicas do Serviço de Controle de Acesso acessíveis estiverem configurados corretamente no arquivo \textit{"/conf/ACSFaultToleranceConfiguration.lua"}, a API tentará redirecionar a chamada para uma réplica sem falha sempre que houver uma das seguintes falhas durante uma requisição:

\begin{verbatim}
  IDL:omg.org/CORBA/NO_RESPONSE:1.0
  IDL:omg.org/CORBA/COMM_FAILURE:1.0
  IDL:omg.org/CORBA/OBJECT_NOT_EXIST:1.0
  IDL:omg.org/CORBA/TRANSIENT:1.0
  IDL:omg.org/CORBA/TIMEOUT:1.0
  IDL:omg.org/CORBA/NO_RESOURCES:1.0
  IDL:omg.org/CORBA/FREE_MEM:1.0
  IDL:omg.org/CORBA/NO_MEMORY:1.0
  IDL:omg.org/CORBA/INTERNAL:1.0
\end{verbatim}

Note que o método \textit{enableFaultTolerance()} deve ser chamada logo após a chamada do \textit{init()} ou o mecanismo não estará ativado para quaisquer operações da API Openbus ou requisições ao barramento seguintes a sua inicialização.

Os outros métodos da API Openbus serão explicados em mais detalhes a seguir:

\begin{itemize}
  \item \code{boolean init(host, port, props, serverInterceptorConfig,
clientInterceptorConfig, policy)}: Retorna o barramento para o seu estado
inicial, ou seja, desfaz as definições de atributos realizadas. Em seguida,
inicializa o Orb.
  \item \code{ORB getORB()}: Retorna o ORB utilizado.
  \item \code{void run()}: \emph{Loop} que processa requisições remotas. Execução de \emph{orb.run()}.
  \item \code{void destroy()}: Finaliza a execução do barramento.
  \item \code{void finish()}: Finaliza a execução do ORB.
  \item \code{IComponent getACSIComponent()}: Retorna o \emph{stub} IComponent do Serviço de Controle de Acesso.
  \item \code{IAccessControlService getAccessControlService()}: Retorna o \emph{stub} do Serviço de Controle de Acesso.
  \item \code{IRegistryService getRegistryService()}: Retorna o \emph{stub} do Serviço de Registro.
  \item \code{void setCredential(credential)}: Configura a credencial da entidade.
  \item \code{Credential getCredential()}: Retorna a credencial de identificação do usuário frente ao barramento.
  \item \code{Credential getCredentialValidationPolicy()}: Retorna a a política de validação de credencial em uso.
  \item \code{Credential getInterceptedCredential()}: Retorna a credencial interceptada pelo interceptador servidor. Esta operação somente deve ser chamada durante o tratamento de alguma requisição à aplicação do usuário.
  \item \code{void setThreadCredential(credential)}: Define uma credencial a ser utilizada no lugar da credencial corrente. Útil para fornecer uma credencial com o campo delegate preenchido.
  \item \code{void setLeaseExpiredCallback(lec)}: Registra uma callback para a notificação de que o lease da credencial	de identificação do usuário expirou. LeaseExpiredCallback deve ser um objeto que contenha um método de nome \emph{expired()}.
  \item \code{void removeLeaseExpiredCallback(lec)}: Remove uma callback previamente registrada para a notificação de lease expirado.
  \item \code{boolean isConnected()}: Informa o estado de conexão com o barramento.
  \item \code{IRegistryService connectByLoginPassword(user, password}: Realiza uma tentativa de conexão com o barramento. Se a tentativa for bem sucedida, um \emph{stub} do Serviço de Registro é retornado. Caso contrário, o retorno é \emph{false}. Uma exceção além das de CORBA pode ser lançada:
    \subitem \code{InvalidCredentialException}: Caso a credencial seja rejeitada ao tentar obter o Serviço de Registro.
  \item \code{IRegistryService connectByCertificate(name, privateKeyFile,  acsCertificateFile)}: Realiza uma tentativa de conexão com o barramento, utilizando o mecanismo de certificação para o processo de autenticação. Se a tentativa for bem sucedida, um \emph{stub} do Serviço de Registro é retornado. Caso contrário, o retorno é \emph{false}. Uma exceção além das de CORBA pode ser lançada:
    \subitem \code{InvalidCredentialException}: Caso a credencial seja rejeitada ao tentar obter o Serviço de Registro.
  \item \code{IRegistryService connectByCredential(credential)}: Realiza uma tentativa de conexão ao barramento, a partir de uma credencial já existente. Se a tentativa for bem sucedida, um \emph{stub} do Serviço de Registro é retornado. Caso contrário, o retorno é \emph{false}. Uma exceção além das de CORBA pode ser lançada:
    \subitem \code{ACSUnavailableException}: Caso o Serviço de Controle de Acesso não consiga ser contactado.
  \item \code{boolean disconnect()}: Desfaz a conexão atual.
  \item \code{void setInterceptable(interfaceRepID, method, isInterceptable)}: Define se os métodos de uma determinada interface devem ou não ser interceptados pelo interceptador servidor.

  \item \code{boolean isInterceptable(interfaceRepID, method)}: Consulta se o método está sendo interceptado.
  \item \code{boolean enableFaultTolerance()}: Habilita o mecanismo de tolerância a falhas.
  \item \code{boolean isFaultToleranceEnabled()}: Consulta se o mecanismo de tolerância a falhas esta ativado.
\end{itemize}
	
Os outros métodos do \emph{stub} do Serviço de Registro serão explicados em mais detalhes a seguir:

\begin{itemize}
  \item \code{void register(serviceOffer, registryId)}: Registra um serviço no barramento. O serviço é descrito através de uma oferta de serviço. Caso o serviço seja registrado com sucesso, a identificação do mesmo é armazenada no parâmetro de saída registryId.
  \item \code{void unregister(registryId)}: Remove uma oferta de serviço do barramento.
  \item \code{ServiceOfferList find(facets)}: Busca uma ou mais ofertas de serviço no barramento que implementem todas as facetas discriminadas em \emph{facets}.
  \item \code{ServiceOfferList findByCriteria(facets,	properties)}: Busca uma ou mais ofertas de serviço no barramento que implementem todas as facetas discriminadas em \emph{facets} e que atendam aos critérios descritos no parâmetro \emph{criteria}, que é uma lista de propriedades descrita através de strings no formato chave = {valor1, valor2, ..., valorN}.
\end{itemize}

A API utiliza o log do Loop, que possui os níveis de log descritos no arquivo
\emph{openbus/util/Log.lua}. Para alterar o nível de log da API deve-se 
chamar o método \emph{Log:level()} enviando um número referente ao nível de log
como parâmetro. Este método se encontra no módulo \emph{openbus.util.Log}.

\subsection{Primeiros Passos}

Basicamente há dois tipos de aplicações Openbus. Uma que oferta serviços e outra que consome serviços, sendo possível e natural uma aplicação híbrida que tanto oferte quanto consuma. Para ambos os tipos, existe uma certa dinâmica de programação já definida, e é justamente a explicitação dessa dinâmica que será o objetivo deste tópico.

Como facilitador, os processos serão demonstrados com base na demo Hello. De propósito, este é um demo muito simplório, que é composto de um módulo cliente e de outro servidor. O servidor oferta um serviço do tipo Hello num determinado barramento, enquanto que o cliente procura por este serviço no barramento e o utiliza.

\subsubsection{Conexão com o Barramento}

O primeiro passo é firmar uma conexão autenticada com o barramento, o que é necessário tanto para o cliente como para o servidor. Para se concluir a conexão é preciso:

\begin{itemize}
  \item Adquirir a instância que representa o barramento.
  \item Inicializar o barramento.
  \item Efetuar uma autenticação no barramento através de um dos métodos de conexão da API.
\end{itemize}

Existem três modos de autenticação frente ao barramento:

\begin{itemize}
  \item Par usuário e senha.
  \item Certificado digital.
  \item Utilização de uma credencial já existente e válida.
\end{itemize}

O primeiro é destinado normalmente aos clientes que estão acessando o barramento à procura de um serviço. O segundo é mais adequado ao processo servidor que registrará um determinado serviço no barramento. Já o terceiro é útil para aplicações que dependam de terceiros para realizar uma autenticação, ou seja, não tenham acesso a um par usuário/senha nem a um certificado, mas sim a um terceiro elemento que proveja uma credencial válida.

No caso da autenticação via certificado, o responsável pelo serviço deve encaminhar ao administrador do barramento o certificado do serviço, ou seja, um arquivo especial que contenha a chave pública do serviço, dentre outras informações pertinentes. O administrador deve fornecer o certificado do serviço de controle de acesso.

Um exemplo do código necessário para a conexão com o barramento pode ser visto no Código~\ref{lst:conexao}.

\begin{labeledcode}[lua]{conexao}{Conexão com o Barramento}
local openbus = require ``openbus.Openbus"

-- host e porta apenas para fins de exemplo
openbus:init("localhost", 2089)

function main ()
  -- Permite que o ORB comece a aguardar requisições
  openbus:run()

  -- Conexão com o barramento
  local registryService = openbus:connect("HelloService", 
    ``HelloService.key", ``AccessControlService.crt")
end
\end{labeledcode}

\subsubsection{Serviço de Registro}

Um serviço pode ser colocado no barramento através de uma oferta de serviço (\emph{ServiceOffer}), que é uma estrutura que representa o serviço através de uma lista de propriedades (\emph{properties}) e de uma referência a um componente (\emph{member}) SCS. As definições em IDL dessas estruturas podem ser vistas no Código~\ref{lst:offer}.

\begin{labeledcode}[c]{offer}{Definições de Ofertas de Serviço}
typedef sequence<string> PropertyValue;
struct Property {
    string name;
    PropertyValue value;
};

typedef sequence<Property> PropertyList;

struct ServiceOffer {
    PropertyList properties;
    scs::core::IComponent member;
};
\end{labeledcode}

Através da lista de propriedades, é possível caracterizar o serviço. 
	
A arquitetura do Openbus é baseada no modelo de componentes SCS. Os serviços são de fato representados por componentes, que podem apresentar distintas facetas (interfaces). Sendo assim, o primeiro passo para o registro de um serviço é criar um componente que represente esse serviço. Maiores informações sobre a criação de componentes SCS podem ser obtidas nos tutoriais desse projeto, mas um exemplo pode ser conferido no Código~\ref{lst:component}. Nesse exemplo, \emph{HelloImpl} é o nome da classe que implementa a faceta \emph{IHello}.

\begin{labeledcode}[lua]{component}{Instanciação de um Componente SCS}
-- Inicialização do barramento
local openbus = require "openbus.Openbus"
openbus:init("localhost", 2089)

-- A API SCS deve ser carregada após a inicialização do barramento
local scs = require "scs.core.base"

-- especificação das descrições de facetas e receptáculos do componente
local facetDescriptions = {}
facetDescriptions.IHello = {
  name = "IHello",
  interface_name = "IDL:demoidl/hello/IHello:1.0",
  class = Hello
}

-- especificação do ComponentId
local componentId = {
  name = "HelloComponent",
  major_version = 1,
  minor_version = 0,
  patch_version = 0,
  platform_spec = ""
}

-- instanciação do componente
local instance = scs.newComponent(facetDescriptions, {}, componentId)
\end{labeledcode}

O serviço a ser registrado no barramento deve ser descrito através de uma oferta de serviço, que é representada pela estrutura \emph{ServiceOffer}. Pendura-se nessa estrutura o serviço em si, que é representado através de um componente SCS e, opcionalmente, uma lista de propriedades referentes ao serviço. As propriedades devem ser descritas numa estrutura que representa uma lista de propriedades. Um exemplo pode ser conferido no Código~\ref{lst:registering}.

\begin{labeledcode}[lua]{registering}{Registro de uma Oferta de Serviço}
-- definição da oferta
local offer = { properties = {}, member = instance.IComponent }

-- registro do serviço
local status, registrationId = registryService:register(offer)
\end{labeledcode}

Até este ponto, o servidor basicamente se autenticou ao barramento e registrou o serviço. O último passo necessário para finalizar o código do servidor é habilitar o processo servidor a escutar as requisições CORBA que serão direcionadas para o serviço ofertado, o que pode ser feito com o uso do método da API \emph{run()} descrito anteriormente na Seção \ref{api}.

\subsubsection{Processo Cliente}

Como o servidor, o cliente necessita de se autenticar ao barramento. Portanto, os mesmos passos aplicados ao servidor para a autenticação devem ser repetidos, com exceção de que o cliente geralmente se autentica através do mecanismo de usuário e senha, como no Código~\ref{lst:clientauth}.

\begin{labeledcode}[lua]{clientauth}{Autenticação da Aplicação Cliente}
-- userLogin e userPassword são variáveis String contendo o 
-- nome de usuário e senha.
local registryService = openbus:connect(userLogin, userPassword)
\end{labeledcode}

Após a conexão bem sucedida com o barramento, o próximo passo é obter o serviço desejado. Isso pode ser feito através de uma chamada ao método \emph{find()} do Serviço de Registro, que retorna uma lista de ofertas de serviço que implementam a faceta que o usuário deseja. Um exemplo pode ser conferido no Código~\ref{lst:clientsearch}.

\begin{labeledcode}[lua]{clientsearch}{Busca por Ofertas de Serviço}
-- busca no barramento serviços que implementem uma faceta de nome IHello.
-- uma lista de *ofertas de serviço* é retornada para o usuário.
local offers = registryService:find({"IHello"})

-- nessa demo há somente uma oferta de serviço publicada, então simplesmente
-- acessamos a primeira da lista.
local offer = offers[1];
\end{labeledcode}

Como visto anteriormente, a oferta de serviço contém uma referência para um componente SCS ou, mais especificamente, para sua faceta IComponent. Como esse componente pode apresentar diversas facetas, o usuário deve obter a faceta que deseja utilizar. No exemplo há somente uma faceta além das facetas básicas do modelo SCS, a IHello. A faceta recebida na oferta, IComponent, oferece métodos (\emph{getFacet} e \emph{getFacetByName}) para que o usuário possa obter um objeto CORBA que represente a faceta desejada. De posse do objeto CORBA, o usuário deve efetuar um \emph{narrow} para mapeá-lo para a interface desejada e daí em diante o programador estará apto a utilizar essa faceta / serviço. Um exemplo pode ser visto no Código~\ref{lst:clientfacet}.

\begin{labeledcode}[lua]{clientfacet}{Acesso à Faceta Desejada}
-- obtenção da faceta IHello
local component = offer.member;
local helloFacet = component:getFacet("IDL:demoidl/hello/IHello:1.0")
helloFacet = orb:narrow(helloFacet, "IDL:demoidl/hello/IHello:1.0")

-- utilização da faceta / serviço IHello
helloFacet:sayHello()
\end{labeledcode}

Os códigos completos podem ser conferidos nas demos do projeto.

\end{document}
